#include "U8glib.h"

U8GLIB_ST7920_128X64_1X u8g(6, 5, 4, 7);  // Enable, RW, RS, RESET

#define KEY_NONE 0
#define KEY_PREV 1
#define KEY_NEXT 2
#define KEY_SELECT 3
#define KEY_BACK 4

// Define keypad buttons
const byte NONE = 0;
const byte LEFT = 1;
const byte UP = 2;
const byte RIGHT = 3;
const byte DOWN = 4;
const byte SELECT = 5;

const byte keypadPin = A15;
byte key = 0;

uint8_t uiKeyCodeFirst = KEY_NONE;
uint8_t uiKeyCodeSecond = KEY_NONE;
uint8_t uiKeyCode = KEY_NONE;

uint8_t menu_current = 0;
uint8_t menu_redraw_required = 0;
uint8_t last_key_code = KEY_NONE;
#define MENU_ITEMS 4
const char *menu_strings[MENU_ITEMS] = { "First Line", "Second Item", "3333333", "abcdefg" };


void uiSetup(void) {
  // configure input keys
  pinMode(keypadPin, INPUT_PULLUP);  // set pin to input with pullup
}

void uiStep(void) {
  uiKeyCodeSecond = uiKeyCodeFirst;
  key = getKey();

  switch (key) {
    case LEFT:
      uiKeyCodeFirst = KEY_PREV;
      break;
    case RIGHT:
      uiKeyCodeFirst = KEY_NEXT;
      break;
    case UP:
      uiKeyCodeFirst = KEY_BACK;
      break;
    case DOWN:
      uiKeyCodeFirst = KEY_SELECT;
      break;
    default:
      uiKeyCodeFirst = KEY_NONE;
  }

  if (uiKeyCodeSecond == uiKeyCodeFirst)
    uiKeyCode = uiKeyCodeFirst;
  else
    uiKeyCode = KEY_NONE;
}

void updateMenu(void) {
  if (uiKeyCode != KEY_NONE && uiKeyCode != uiKeyCodeFirst) {
    uiKeyCode = KEY_NONE;
    return;
  }

  switch (uiKeyCode) {
    case KEY_NEXT:
      menu_current++;
      if (menu_current >= MENU_ITEMS)
        menu_current = 0;
      menu_redraw_required = 1;
      break;
    case KEY_PREV:
      if (menu_current == 0)
        menu_current = MENU_ITEMS;
      menu_current--;
      menu_redraw_required = 1;
      break;
  }
}

void drawMenu(void) {
  uint8_t i, h;
  u8g_uint_t w, d;

  u8g.setFont(u8g_font_6x13);
  u8g.setFontRefHeightText();
  u8g.setFontPosTop();

  h = u8g.getFontAscent() - u8g.getFontDescent();
  w = u8g.getWidth();
  for (i = 0; i < MENU_ITEMS; i++) {
    d = (w - u8g.getStrWidth(menu_strings[i])) / 2;
    u8g.setDefaultForegroundColor();
    if (i == menu_current) {
      u8g.drawBox(0, i * h + 1, w, h);
      u8g.setDefaultBackgroundColor();
    }
    u8g.drawStr(d, i * h, menu_strings[i]);
  }
}

void setup() {
  // rotate screen, if required
  // u8g.setRot180();

  Serial.begin(9600);  // Initialize serial communication
  uiSetup();           // setup key detection and debounce algorithm
  menu_redraw_required = 1;      // force initial redraw
}

void loop() {
  uiStep();  // check for key press

  if (menu_redraw_required != 0) {
    u8g.firstPage();
    do {
      drawMenu();
    } while (u8g.nextPage());
    menu_redraw_required = 0;
  }

  updateMenu();  // update menu bar

  // Add Serial.println to debug key values
  Serial.print("Analog value: ");
  Serial.println(analogRead(keypadPin));
  Serial.print("Button: ");
  Serial.println(key);

  delay(100);  // Add a short delay for stability
}

byte getKey() {
  int val = 0;
  byte button = NONE; // set default value to NONE
  val = analogRead(keypadPin);

  if (val <= 20) {
    button = LEFT;
  } else if ((val >= 100) && (val <= 200)) {
    button = UP;
  } else if ((val >= 300) && (val <= 400)) {
    button = DOWN;
  } else if ((val >= 500) && (val <= 600)) {
    button = RIGHT;
  } else if ((val >= 700) && (val <= 800)) {
    button = SELECT;
  }

  return button;
}
